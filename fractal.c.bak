#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <string.h>
#include "bmp.c"

#define WIDTH 400
#define HEIGHT 400

#define RENDER_AREA 1.5

unsigned char image[HEIGHT][WIDTH][3];

//A julia set generator
unsigned char julia_point(double zx, double zy, double cx, double cy, unsigned int iterations){
	unsigned int n;
  double tempX;
  for(n = 0; n < iterations; n++){
    tempX = zx;
    zx = (zx*zx)-(zy*zy) + cx;
    zy = (2.0*tempX*zy) + cy;
    if(sqrt((zx*zx) + (zy*zy)) > 4.0){
      return 0;
    }
  }
	return 1;
}

//c value for quaternions
// -1,0.2,0,0
double qcr = -0.2;
double qca = 0.8;
double qcb = -0.1;
double qcc = 0.0;

//A quaternions julia generator
//Quaternion (zr + za*i + zb*j + zc*k)
unsigned char quat_julia_point(double zr, double za, double zb, double zc, unsigned int iterations){
	unsigned int n;
	double r;
	double a;
	double b;
	double c;
	for(n = 0; n < iterations; n++){
		r = zr; a = za; b = zb; c = zc;
		//Quaternion multiplication           and addition of c 
		zr = ( r * r - a * a - b * b - c * c ) + qcr;
		za = ( r * a + a * r + b * c - c * b ) + qca;
		zb = ( r * b + b * r + c * a - a * c ) + qcb;
		zc = ( r * c + c * r + a * b - b * a ) + qcc; 
		if(sqrt(zr*zr + za*za + zb*zb + zc*zc) > 4.0){
      return 0;
    }
	}
	return 1;
}

//March a ray until intersection
unsigned char ray_march(double *x, double *y, double *z, double dx, double dy, double dz, double slice, unsigned int maxSteps, unsigned int iters){
	//If the ray has hit the area to check for collisions or not
	unsigned char hitRenderArea = 0;
	//ray march
	for(unsigned int i = 0; i < maxSteps; i++){
		*x += dx;
		*y += dy;
		*z += dz;
		if(*x < -RENDER_AREA || *x > RENDER_AREA || *y < -RENDER_AREA || *y > RENDER_AREA || *z < -RENDER_AREA || *z > RENDER_AREA){
			//A ray that entered and exited the rendering area with no coliision will not reenter
			if(hitRenderArea){return 0;}																																																										 																																																												 
			//If we aren't in the rendering area, no need to check for collision
			continue;
		}
		hitRenderArea = 1;
		if(quat_julia_point(*x, *y, *z, slice, iters)){
			return 1;
		}
	}
	return 0;
}

//Get color for a specific pixel
uint32_t get_color(unsigned int x, unsigned int y, unsigned int width, unsigned int height, double rotate){
	double zx;
	double zy;
	//zz is put into equation for cx
	double zz;
	double slice;
	unsigned int iters;
	unsigned int maxSteps;
	double stepDist;
	double dx;
	double dy;
	double dz;
	double cameraMag;
	//init c
	slice = 0.0;
	
	//starting point
	zx = 0.0;
	zy = 0.0;
	zz = -2.0;
	
	//rotate starting point
	double theta = atan2(zz, zy);
	double mag = sqrt(zy*zy+zz*zz);
	
	theta += rotate;
	
	zy = cos(theta) * mag;
	zz = sin(theta) * mag;
	
	//set dx, dy, and dz
	dz = 1;
	//90 degree fov, should be setable
	dx = ((double)x)/((double)width)*2.0-1.0;
	dy = ((double)y)/((double)height)*2.0-1.0;

	//rotate direction
	//rotate starting point
	
	theta = atan2(dz, dy);
	mag = sqrt(dy*dy+dz*dz);
	
	theta += rotate;
	
	dy = cos(theta) * mag;
	dz = sin(theta) * mag;
	
	//set parameters
	stepDist = 0.002;
	maxSteps = 2000;
	iters = 50;
	
	//normalize d, and divide by stepDist
	double dist = sqrt(dx*dx + dy*dy + dz*dz);
	dx/=(dist/stepDist);
	dy/=(dist/stepDist);
	dz/=(dist/stepDist);
	
	if(ray_march(&zx, &zy, &zz, dx, dy, dz, slice, maxSteps, iters)){
		unsigned char red = (unsigned char)((zx+RENDER_AREA) * (255.0/(2.0*RENDER_AREA)));
		unsigned char green = (unsigned char)((zy+RENDER_AREA) * (255.0/(2.0*RENDER_AREA)));
		unsigned char blue = (unsigned char)((zz+RENDER_AREA) * (255.0/(2.0*RENDER_AREA)));
		return (uint32_t)((red << 16) + (green << 8) + blue);
		}
	return 0x00ffffff;
}

void render_image(char * filename, double rotate){
	//X and Y pixel locations
	unsigned int pixelX;
	unsigned int pixelY;
	//Image width and height
	unsigned int width;
	unsigned int height;
	//returned packed pixel color
	uint32_t color;
	
	//set width and height
	width = WIDTH;
	height = HEIGHT;

	
	//iterate through each pixel
	for(pixelX = 0; pixelX < width; pixelX++){
		for(pixelY = 0; pixelY < height; pixelY++){
			color = get_color(pixelX, pixelY, width, height, rotate);
			image[pixelY][pixelX][2] = (unsigned char)((color >> 16)&0xff);
			image[pixelY][pixelX][1] = (unsigned char)((color >> 8)&0xff);
			image[pixelY][pixelX][0] = (unsigned char)(color & 0xff);
		}
	}												 
	//write image
	generateBitmapImage((unsigned char *)image, height, width, filename);
}

int main(int argc, char **argv){
	char * filename;
	//rotate amount
	double rotate = 0.0;
	if(argc != 2){
		printf("Usage: fractal [out file]\n");
		exit(1);
	}
	filename = argv[1];
	render_image(filename, rotate);
}
